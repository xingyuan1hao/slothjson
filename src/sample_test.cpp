////////////////////////////////////////////////////////////////////////////////
// NOTE : Generated by slothjson. It is NOT supposed to modify this file.
////////////////////////////////////////////////////////////////////////////////
#include "sample_test.h"

namespace slothjson {

sample_struct_t::sample_struct_t()
{
    bool_val = true;
    __skip_bool_val = false;
    __json_has_bool_val = false;

    str_val = "test";
    __skip_str_val = false;
    __json_has_str_val = false;

    int_val = -111111;
    __skip_int_val = false;
    __json_has_int_val = false;

    uint_val = 111111;
    __skip_uint_val = false;
    __json_has_uint_val = false;

    double_val = 111111.111111;
    __skip_double_val = false;
    __json_has_double_val = false;

    char_val = 'a';
    __skip_char_val = false;
    __json_has_char_val = false;

    uchar_val = 128;
    __skip_uchar_val = false;
    __json_has_uchar_val = false;

    short_val = -256;
    __skip_short_val = false;
    __json_has_short_val = false;

    ushort_val = 512;
    __skip_ushort_val = false;
    __json_has_ushort_val = false;

    int64_val = -9223372036854775807;
    __skip_int64_val = false;
    __json_has_int64_val = false;

    uint64_val = 0xffffffffffffffff;
    __skip_uint64_val = false;
    __json_has_uint64_val = false;

    float_val = 111111.111111;
    __skip_float_val = false;
    __json_has_float_val = false;

    __skip_vec_val = false;
    __json_has_vec_val = false;

    __skip_str_map_val = false;
    __json_has_str_map_val = false;
}

sample_struct_t& sample_struct_t::operator=(const sample_struct_t& obj_val)
{
    this->bool_val = obj_val.bool_val;
    this->str_val = obj_val.str_val;
    this->int_val = obj_val.int_val;
    this->uint_val = obj_val.uint_val;
    this->double_val = obj_val.double_val;
    this->char_val = obj_val.char_val;
    this->uchar_val = obj_val.uchar_val;
    this->short_val = obj_val.short_val;
    this->ushort_val = obj_val.ushort_val;
    this->int64_val = obj_val.int64_val;
    this->uint64_val = obj_val.uint64_val;
    this->float_val = obj_val.float_val;
    this->vec_val = obj_val.vec_val;
    this->str_map_val = obj_val.str_map_val;
    return *this;
}

bool sample_struct_t::operator==(const sample_struct_t& obj_val) const
{
    if (!(this->bool_val == obj_val.bool_val)) return false;
    if (!(this->str_val == obj_val.str_val)) return false;
    if (!(this->int_val == obj_val.int_val)) return false;
    if (!(this->uint_val == obj_val.uint_val)) return false;
    if (!(this->double_val == obj_val.double_val)) return false;
    if (!(this->char_val == obj_val.char_val)) return false;
    if (!(this->uchar_val == obj_val.uchar_val)) return false;
    if (!(this->short_val == obj_val.short_val)) return false;
    if (!(this->ushort_val == obj_val.ushort_val)) return false;
    if (!(this->int64_val == obj_val.int64_val)) return false;
    if (!(this->uint64_val == obj_val.uint64_val)) return false;
    if (!(this->float_val == obj_val.float_val)) return false;
    if (!(this->vec_val == obj_val.vec_val)) return false;
    if (!(this->str_map_val == obj_val.str_map_val)) return false;
    return true;
}

bool sample_struct_t::encode(allocator_t& alloc, rapidjson::Value& json_val) const
{
    do
    {
        json_val.SetObject();
        if (!__skip_bool_val && !encode_field(bool_val, "bool_val", alloc, json_val)) break;
        if (!__skip_str_val && !encode_field(str_val, "str_val", alloc, json_val)) break;
        if (!__skip_int_val && !encode_field(int_val, "int_val", alloc, json_val)) break;
        if (!__skip_uint_val && !encode_field(uint_val, "uint_val", alloc, json_val)) break;
        if (!__skip_double_val && !encode_field(double_val, "double_val", alloc, json_val)) break;
        if (!__skip_char_val && !encode_field(char_val, "char_val", alloc, json_val)) break;
        if (!__skip_uchar_val && !encode_field(uchar_val, "uchar_val", alloc, json_val)) break;
        if (!__skip_short_val && !encode_field(short_val, "short_val", alloc, json_val)) break;
        if (!__skip_ushort_val && !encode_field(ushort_val, "ushort_val", alloc, json_val)) break;
        if (!__skip_int64_val && !encode_field(int64_val, "int64_val", alloc, json_val)) break;
        if (!__skip_uint64_val && !encode_field(uint64_val, "uint64_val", alloc, json_val)) break;
        if (!__skip_float_val && !encode_field(float_val, "float_val", alloc, json_val)) break;
        if (!__skip_vec_val && !encode_field(vec_val, "vec_val", alloc, json_val)) break;
        if (!__skip_str_map_val && !encode_field(str_map_val, "str_map_val", alloc, json_val)) break;

        return true;
    } while (0);

    return false;
}

bool sample_struct_t::decode(const rapidjson::Value& json_val)
{
    do
    {
        if (!decode_field(json_val, "bool_val", bool_val, __json_has_bool_val)) break;
        if (!decode_field(json_val, "str_val", str_val, __json_has_str_val)) break;
        if (!decode_field(json_val, "int_val", int_val, __json_has_int_val)) break;
        if (!decode_field(json_val, "uint_val", uint_val, __json_has_uint_val)) break;
        if (!decode_field(json_val, "double_val", double_val, __json_has_double_val)) break;
        if (!decode_field(json_val, "char_val", char_val, __json_has_char_val)) break;
        if (!decode_field(json_val, "uchar_val", uchar_val, __json_has_uchar_val)) break;
        if (!decode_field(json_val, "short_val", short_val, __json_has_short_val)) break;
        if (!decode_field(json_val, "ushort_val", ushort_val, __json_has_ushort_val)) break;
        if (!decode_field(json_val, "int64_val", int64_val, __json_has_int64_val)) break;
        if (!decode_field(json_val, "uint64_val", uint64_val, __json_has_uint64_val)) break;
        if (!decode_field(json_val, "float_val", float_val, __json_has_float_val)) break;
        if (!decode_field(json_val, "vec_val", vec_val, __json_has_vec_val)) break;
        if (!decode_field(json_val, "str_map_val", str_map_val, __json_has_str_map_val)) break;

        return true;
    } while (0);

    return false;
}

bool encode(const sample_struct_t& obj_val, allocator_t& alloc, rapidjson::Value& json_val)
{
    return obj_val.encode(alloc, json_val);
}

bool decode(const rapidjson::Value& json_val, sample_struct_t& obj_val)
{
    return obj_val.decode(json_val);
}

} // namespace slothjson